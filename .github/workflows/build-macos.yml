name: Build macOS Universal DMG

on:
    push:
      branches: [ main ]
    workflow_dispatch:

jobs:
  build-macos:
    runs-on: macos-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Build for osx-x64
        run: dotnet publish NetworkMonitor.csproj -c Release -r osx-x64 --self-contained true -o publish-x64

      - name: Build for osx-arm64
        run: dotnet publish NetworkMonitor.csproj -c Release -r osx-arm64 --self-contained true -o publish-arm64

      - name: Analyze build outputs
        run: |
          echo "=== 分析构建输出 ==="
          
          echo "x64 构建输出:"
          ls -la publish-x64/
          
          echo -e "\narm64 构建输出:"
          ls -la publish-arm64/
          
          echo -e "\n=== 检查主程序架构 ==="
          echo "x64 主程序:"
          file publish-x64/NetworkMonitor
          lipo -info publish-x64/NetworkMonitor 2>/dev/null || echo "不是 Mach-O 文件或无法读取架构"
          
          echo -e "\narm64 主程序:"
          file publish-arm64/NetworkMonitor
          lipo -info publish-arm64/NetworkMonitor 2>/dev/null || echo "不是 Mach-O 文件或无法读取架构"
          
          echo -e "\n=== 检查动态库架构 ==="
          for dylib in publish-x64/*.dylib; do
            if [ -f "$dylib" ]; then
              echo "x64 - $(basename "$dylib"):"
              lipo -info "$dylib" 2>/dev/null || echo "  无法读取架构信息"
            fi
          done
          
          for dylib in publish-arm64/*.dylib; do
            if [ -f "$dylib" ]; then
              echo "arm64 - $(basename "$dylib"):"
              lipo -info "$dylib" 2>/dev/null || echo "  无法读取架构信息"
            fi
          done

      - name: Create universal binary and app bundle
        run: |
          # 创建应用包结构
          mkdir -p NetworkMonitor.app/Contents/MacOS
          mkdir -p NetworkMonitor.app/Contents/Resources
          
          # 验证构建输出
          echo "检查构建输出..."
          ls -la publish-x64/
          ls -la publish-arm64/
          
          # 合并主程序为 Universal Binary
          echo "创建 Universal Binary..."
          lipo -create \
            publish-x64/NetworkMonitor \
            publish-arm64/NetworkMonitor \
            -output NetworkMonitor.app/Contents/MacOS/NetworkMonitor
          
          # 验证 Universal Binary
          lipo -info NetworkMonitor.app/Contents/MacOS/NetworkMonitor
          
          # 设置可执行权限
          chmod +x NetworkMonitor.app/Contents/MacOS/NetworkMonitor
          
          # 处理 .dylib 文件 - 智能架构检测和合并
          echo "处理动态库..."
          
          # 收集所有 .dylib 文件
          if ls publish-x64/*.dylib 1> /dev/null 2>&1; then
            for dylib_x64 in publish-x64/*.dylib; do
              if [ -f "$dylib_x64" ]; then
                dylib_name=$(basename "$dylib_x64")
                dylib_arm64="publish-arm64/$dylib_name"
          
                echo "处理 $dylib_name..."
          
                if [ -f "$dylib_arm64" ]; then
                  # 检查两个文件的架构
                  x64_arch=$(lipo -info "$dylib_x64" 2>/dev/null | grep -o 'x86_64\|arm64' || echo "")
                  arm64_arch=$(lipo -info "$dylib_arm64" 2>/dev/null | grep -o 'x86_64\|arm64' || echo "")
          
                  echo "  x64 版本架构: ${x64_arch:-未知}"
                  echo "  arm64 版本架构: ${arm64_arch:-未知}"
          
                  # 尝试合并，如果失败则使用备选方案
                  if lipo -create "$dylib_x64" "$dylib_arm64" -output "NetworkMonitor.app/Contents/MacOS/$dylib_name" 2>/dev/null; then
                    echo "  ✓ 成功合并 $dylib_name"
                  else
                    echo "  ⚠️  无法合并 $dylib_name，使用智能选择..."
          
                    # 如果无法合并，选择更合适的版本
                    # 检查哪个版本的架构更匹配目标
                    if [[ "$x64_arch" == *"x86_64"* ]] && [[ "$arm64_arch" == *"arm64"* ]]; then
                      # 理想情况：创建符号链接处理多架构
                      echo "  创建架构特定的动态库..."
                      cp "$dylib_arm64" "NetworkMonitor.app/Contents/MacOS/$dylib_name"
                    elif [[ "$arm64_arch" == *"arm64"* ]]; then
                      echo "  使用 ARM64 版本"
                      cp "$dylib_arm64" "NetworkMonitor.app/Contents/MacOS/"
                    elif [[ "$x64_arch" == *"x86_64"* ]]; then
                      echo "  使用 x86_64 版本"
                      cp "$dylib_x64" "NetworkMonitor.app/Contents/MacOS/"
                    else
                      # 备选：比较文件大小，使用更大的
                      if [ $(stat -f%z "$dylib_x64") -ge $(stat -f%z "$dylib_arm64") ]; then
                        echo "  使用较大的 x64 版本"
                        cp "$dylib_x64" "NetworkMonitor.app/Contents/MacOS/"
                      else
                        echo "  使用较大的 arm64 版本"
                        cp "$dylib_arm64" "NetworkMonitor.app/Contents/MacOS/"
                      fi
                    fi
                  fi
                else
                  echo "  只有 x64 版本，直接复制"
                  cp "$dylib_x64" "NetworkMonitor.app/Contents/MacOS/"
                fi
              fi
            done
          fi
          
          # 检查是否有只在 ARM64 版本中存在的 .dylib
          if ls publish-arm64/*.dylib 1> /dev/null 2>&1; then
            for dylib_arm64 in publish-arm64/*.dylib; do
              if [ -f "$dylib_arm64" ]; then
                dylib_name=$(basename "$dylib_arm64")
          
                # 如果这个文件还没有被处理过
                if [ ! -f "NetworkMonitor.app/Contents/MacOS/$dylib_name" ]; then
                  echo "  发现额外的 ARM64 库: $dylib_name"
                  cp "$dylib_arm64" "NetworkMonitor.app/Contents/MacOS/"
                fi
              fi
            done
          fi
          
          # 复制其他必要文件（配置文件、资源等）
          if [ -f "publish-arm64/NetworkMonitor.runtimeconfig.json" ]; then
            cp publish-arm64/NetworkMonitor.runtimeconfig.json NetworkMonitor.app/Contents/MacOS/
          fi
          
          if [ -f "publish-arm64/NetworkMonitor.deps.json" ]; then
            cp publish-arm64/NetworkMonitor.deps.json NetworkMonitor.app/Contents/MacOS/
          fi
          
          # 复制其他资源文件
          for file in publish-arm64/*; do
            if [[ -f "$file" && ! "$file" =~ \.(dylib|exe)$ && ! "$file" =~ NetworkMonitor$ ]]; then
              filename=$(basename "$file")
              if [[ ! "$filename" =~ \.(json)$ ]]; then
                cp "$file" "NetworkMonitor.app/Contents/MacOS/"
              fi
            fi
          done
          
          # 创建 Info.plist
          cat > NetworkMonitor.app/Contents/Info.plist <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
           "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>CFBundleName</key>
            <string>NetworkMonitor</string>
            <key>CFBundleDisplayName</key>
            <string>Network Monitor</string>
            <key>CFBundleExecutable</key>
            <string>NetworkMonitor</string>
            <key>CFBundleIdentifier</key>
            <string>com.example.networkmonitor</string>
            <key>CFBundleVersion</key>
            <string>1.0.0</string>
            <key>CFBundleShortVersionString</key>
            <string>1.0.0</string>
            <key>CFBundlePackageType</key>
            <string>APPL</string>
            <key>CFBundleInfoDictionaryVersion</key>
            <string>6.0</string>
            <key>LSMinimumSystemVersion</key>
            <string>10.15</string>
            <key>NSHighResolutionCapable</key>
            <true/>
            <key>NSPrincipalClass</key>
            <string>NSApplication</string>
          </dict>
          </plist>
          EOF
          
          # 创建 PkgInfo 文件
          echo "APPL????" > NetworkMonitor.app/Contents/PkgInfo
          
          # 验证应用包结构
          echo "应用包结构:"
          find NetworkMonitor.app -type f -exec ls -la {} \;

      - name: Sign app bundle with ad-hoc signature
        run: |
          echo "=== 开始 Ad-hoc 签名 ==="
          
          # 对整个应用包进行 ad-hoc 签名
          echo "对应用包进行临时签名..."
          codesign --force --deep --sign - NetworkMonitor.app
          
          # 验证签名
          echo "验证签名结果..."
          if codesign --verify NetworkMonitor.app; then
            echo "✅ 应用签名成功"
          else
            echo "❌ 应用签名失败"
            exit 1
          fi
          
          # 显示签名详细信息
          echo "签名详细信息:"
          codesign --display --verbose=2 NetworkMonitor.app
          
          # 验证主程序签名
          echo "主程序签名信息:"
          codesign --display --verbose=2 NetworkMonitor.app/Contents/MacOS/NetworkMonitor
          
          # 检查所有签名文件
          echo "检查所有已签名的组件:"
          find NetworkMonitor.app -type f \( -name "*.dylib" -o -name "NetworkMonitor" \) -exec echo "检查: {}" \; -exec codesign --verify {} \; 2>/dev/null || true

      - name: Verify app bundle
        run: |
          echo "验证应用包..."
          
          # 检查可执行文件架构
          echo "主程序架构:"
          file NetworkMonitor.app/Contents/MacOS/NetworkMonitor
          lipo -info NetworkMonitor.app/Contents/MacOS/NetworkMonitor
          
          # 检查动态库架构
          echo "动态库架构:"
          for dylib in NetworkMonitor.app/Contents/MacOS/*.dylib; do
            if [ -f "$dylib" ]; then
              echo "$(basename "$dylib"):"
              lipo -info "$dylib" || echo "  单架构或非Mach-O文件"
            fi
          done
          
          # 最终签名验证
          echo "最终签名验证..."
          codesign --verify --verbose NetworkMonitor.app
          
          # 显示签名状态
          echo "签名状态摘要:"
          codesign --display --verbose=1 NetworkMonitor.app

      - name: Create enhanced DMG
        run: |
          # 安装 create-dmg 以获得更好的 DMG
          brew install create-dmg
          
          # 创建临时文件夹用于 DMG 内容
          mkdir -p dmg-temp
          cp -R NetworkMonitor.app dmg-temp/
          
          # 创建应用程序链接
          ln -s /Applications dmg-temp/Applications
          
          # 使用 create-dmg 创建美观的 DMG
          create-dmg \
            --volname "Network Monitor" \
            --window-pos 200 120 \
            --window-size 800 400 \
            --icon-size 100 \
            --icon "NetworkMonitor.app" 200 190 \
            --hide-extension "NetworkMonitor.app" \
            --app-drop-link 600 185 \
            --hdiutil-quiet \
            "NetworkMonitor-Universal.dmg" \
            dmg-temp/ || \
          {
            echo "create-dmg 失败，使用 hdiutil 作为备选..."
            hdiutil create -volname "Network Monitor" \
              -srcfolder dmg-temp \
              -ov -format UDZO NetworkMonitor-Universal.dmg
          }

      - name: Verify DMG and signing
        run: |
          echo "=== 验证 DMG 和签名 ==="
          
          # 检查 DMG 文件
          echo "DMG 文件信息:"
          ls -lh NetworkMonitor-Universal.dmg
          
          # 验证 DMG 完整性
          echo "验证 DMG 完整性..."
          hdiutil verify NetworkMonitor-Universal.dmg
          
          # 测试挂载并验证内部应用的签名
          echo "测试 DMG 挂载并验证签名..."
          hdiutil attach NetworkMonitor-Universal.dmg -readonly -nobrowse -mountpoint /tmp/test-mount
          
          echo "DMG 内容:"
          ls -la /tmp/test-mount/
          
          # 验证 DMG 中应用的架构
          echo "DMG 中应用的架构:"
          lipo -info /tmp/test-mount/NetworkMonitor.app/Contents/MacOS/NetworkMonitor
          
          # 验证 DMG 中应用的签名
          echo "DMG 中应用的签名状态:"
          codesign --verify --verbose /tmp/test-mount/NetworkMonitor.app
          codesign --display --verbose=2 /tmp/test-mount/NetworkMonitor.app
          
          # 卸载
          hdiutil detach /tmp/test-mount
          
          # 计算哈希值
          echo "DMG 信息摘要:"
          echo "SHA256: $(shasum -a 256 NetworkMonitor-Universal.dmg | cut -d' ' -f1)"
          echo "大小: $(ls -lh NetworkMonitor-Universal.dmg | awk '{print $5}')"
          
          echo "✅ 构建完成！应用已使用 ad-hoc 签名，用户首次运行时需要右键点击选择'打开'。"

      - name: Upload DMG Artifact
        uses: actions/upload-artifact@v4
        with:
          name: NetworkMonitor-Universal-DMG
          path: NetworkMonitor-Universal.dmg
          retention-days: 30

      - name: Upload App Bundle (for debugging)
        uses: actions/upload-artifact@v4
        with:
          name: NetworkMonitor-App-Bundle
          path: NetworkMonitor.app/
          retention-days: 7